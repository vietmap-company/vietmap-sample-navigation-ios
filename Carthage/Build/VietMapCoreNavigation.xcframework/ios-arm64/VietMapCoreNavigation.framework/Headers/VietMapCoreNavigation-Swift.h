#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
#ifndef VIETMAPCORENAVIGATION_SWIFT_H
#define VIETMAPCORENAVIGATION_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreLocation;
@import Foundation;
@import MapboxDirections;
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="VietMapCoreNavigation",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)



@class NSCoder;
@class NSString;
@class NSUnitLength;
@class NSAttributedString;

/// Provides appropriately formatted, localized descriptions of linear distances.
SWIFT_CLASS_NAMED("DistanceFormatter")
@interface MBDistanceFormatter : NSLengthFormatter
/// Intializes a new <code>DistanceFormatter</code>.
/// \param approximate approximates the distances.
///
- (nonnull instancetype)initWithApproximate:(BOOL)approximate OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
/// Returns a more human readable <code>String</code> from a given <code>CLLocationDistance</code>.
/// The user’s <code>Locale</code> is used here to set the units.
- (NSString * _Nonnull)stringFrom:(CLLocationDistance)distance SWIFT_WARN_UNUSED_RESULT;
- (NSString * _Nonnull)stringFromMeters:(double)numberInMeters SWIFT_WARN_UNUSED_RESULT;
- (NSMeasurement<NSUnitLength *> * _Nonnull)measurementOfDistance:(CLLocationDistance)distance SWIFT_WARN_UNUSED_RESULT SWIFT_AVAILABILITY(ios,introduced=10.0);
/// Returns an attributed string containing the formatted, converted distance.
/// <code>NSAttributedStringKey.quantity</code> is applied to the numeric quantity.
- (NSAttributedString * _Nullable)attributedStringForObjectValue:(id _Nonnull)obj withDefaultAttributes:(NSDictionary<NSAttributedStringKey, id> * _Nullable)attrs SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSNumber;

/// Feedback Model Object for End Of Route Experience.
SWIFT_CLASS("_TtC21VietMapCoreNavigation18EndOfRouteFeedback")
@interface EndOfRouteFeedback : NSObject
- (nonnull instancetype)initWithRating:(NSNumber * _Nullable)ratingNumber comment:(NSString * _Nullable)comment;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM_NAMED(NSInteger, MBFeedbackSource, "FeedbackSource", closed) {
  MBFeedbackSourceUser = 0,
  MBFeedbackSourceReroute = 1,
  MBFeedbackSourceUnknown = 2,
};

/// Feedback type is used to specify the type of feedback being recorded with <code>RouteController.recordFeedback()</code>.
typedef SWIFT_ENUM_NAMED(NSInteger, MBFeedbackType, "FeedbackType", closed) {
/// Indicates general feedback. You should provide a <code>description</code> string to <code>RouteController.recordFeedback()</code> to elaborate on the feedback if possible.
  MBFeedbackTypeGeneral = 0,
/// Identifies the feedback as the location of an accident or crash
  MBFeedbackTypeAccident = 1,
/// Identifies the feedback as the location of a road hazard such as debris, stopped vehicles, etc.
  MBFeedbackTypeHazard = 2,
/// Identifies the feedback as the location of a closed road that should not allow vehicles
  MBFeedbackTypeRoadClosed = 3,
/// Identifies the feedback as a maneuver that isn’t allowed. For example, if a user is instructed to make a left turn, but the turn isn’t allowed.
  MBFeedbackTypeNotAllowed = 4,
/// Identifies the feedback as the location of a road that should exist along the route.
  MBFeedbackTypeMissingRoad = 5,
/// Identifies the feedback as a maneuver with missing exit information such as an exit number or destination sign.
  MBFeedbackTypeMissingExit = 6,
/// Identifies the feedback as the location of a poor instruction or route choice. This could be used to indicate an ambiguous or poorly-timed turn announcement, or a set of confusing turns.
  MBFeedbackTypeRoutingError = 7,
/// Identifies the feedback as the location of a confusing instruction.
  MBFeedbackTypeConfusingInstruction = 8,
/// Identifies the feedback as a place where traffic should have been reported.
  MBFeedbackTypeReportTraffic = 9,
/// Identifies the feedback as a general map issue.
  MBFeedbackTypeMapIssue = 10,
};


/// <code>NavigationLocationManager</code> is the base location manager which handles permissions and background modes.
SWIFT_CLASS_NAMED("NavigationLocationManager")
@interface MBNavigationLocationManager : CLLocationManager <NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class MBWaypoint;
@class CLLocation;

/// A <code>NavigationMatchOptions</code> object specifies turn-by-turn-optimized criteria for results returned by the Mapbox Map Matching API.
/// <code>NavigationMatchOptions</code> is a subclass of <code>MatchOptions</code> that has been optimized for navigation. Pass an instance of this class into the <code>Directions.calculateRoutes(matching:completionHandler:).</code> method.
/// Note: it is very important you specify the <code>waypoints</code> for the route. Usually the only two values for this <code>IndexSet</code> will be 0 and the length of the coordinates. Otherwise, all coordinates passed through will be considered waypoints.
SWIFT_CLASS_NAMED("NavigationMatchOptions")
@interface MBNavigationMatchOptions : MBMatchOptions
/// Initializes a navigation route options object for routes between the given waypoints and an optional profile identifier optimized for navigation.
/// seealso:
///
/// <a href="https://www.mapbox.com/mapbox-navigation-ios/directions/0.19.0/Classes/MatchOptions.html">MatchOptions</a>
- (nonnull instancetype)initWithWaypoints:(NSArray<MBWaypoint *> * _Nonnull)waypoints profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier OBJC_DESIGNATED_INITIALIZER;
/// Initializes a navigation match options object for routes between the given locations and an optional profile identifier optimized for navigation.
/// seealso:
///
/// <a href="https://www.mapbox.com/mapbox-navigation-ios/directions/0.19.0/Classes/MatchOptions.html">MatchOptions</a>
- (nonnull instancetype)initWithLocations:(NSArray<CLLocation *> * _Nonnull)locations profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
/// Initializes a navigation match options object for routes between the given geographic coordinates and an optional profile identifier optimized for navigation.
/// seealso:
///
/// <a href="https://www.mapbox.com/mapbox-navigation-ios/directions/0.19.0/Classes/MatchOptions.html">MatchOptions</a>
- (nonnull instancetype)initWithCoordinates:(NSArray<NSValue *> * _Nonnull)coordinates profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
@end


/// A <code>NavigationRouteOptions</code> object specifies turn-by-turn-optimized criteria for results returned by the Mapbox Directions API.
/// <code>NavigationRouteOptions</code> is a subclass of <code>RouteOptions</code> that has been optimized for navigation. Pass an instance of this class into the <code>Directions.calculate(_:completionHandler:)</code> method.
SWIFT_CLASS_NAMED("NavigationRouteOptions")
@interface MBNavigationRouteOptions : MBRouteOptions
/// Initializes a navigation route options object for routes between the given waypoints and an optional profile identifier optimized for navigation.
/// seealso:
///
/// <a href="https://www.mapbox.com/mapbox-navigation-ios/directions/0.10.1/Classes/RouteOptions.html">RouteOptions</a>
- (nonnull instancetype)initWithWaypoints:(NSArray<MBWaypoint *> * _Nonnull)waypoints profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier OBJC_DESIGNATED_INITIALIZER;
/// Initializes a navigation route options object for routes between the given locations and an optional profile identifier optimized for navigation.
/// seealso:
///
/// <a href="https://www.mapbox.com/mapbox-navigation-ios/directions/0.19.0/Classes/RouteOptions.html">RouteOptions</a>
- (nonnull instancetype)initWithLocations:(NSArray<CLLocation *> * _Nonnull)locations profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
/// Initializes a route options object for routes between the given geographic coordinates and an optional profile identifier optimized for navigation.
/// seealso:
///
/// <a href="https://www.mapbox.com/mapbox-navigation-ios/directions/0.19.0/Classes/RouteOptions.html">RouteOptions</a>
- (nonnull instancetype)initWithCoordinates:(NSArray<NSValue *> * _Nonnull)coordinates profileIdentifier:(MBDirectionsProfileIdentifier _Nullable)profileIdentifier;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)decoder OBJC_DESIGNATED_INITIALIZER;
@end


/// <code>NavigationSettings</code> provides a wrapper for UserDefaults.
/// Properties are prefixed and before they are stored in UserDefaults.standard.
SWIFT_CLASS_NAMED("NavigationSettings")
@interface MBNavigationSettings : NSObject
/// The volume that the voice controller will use.
/// This volume is relative to the system’s volume where 1.0 is same volume as the system.
@property (nonatomic) float voiceVolume;
/// Specifies whether to mute the voice controller or not.
@property (nonatomic) BOOL voiceMuted;
/// Specifies the preferred distance measurement unit.
/// note:
/// Anything but <code>kilometer</code> and <code>mile</code> will fall back to the default measurement for the current locale.
/// Meters and feets will be used when the presented distances are small enough. See <code>DistanceFormatter</code> for more information.
@property (nonatomic) NSLengthFormatterUnit distanceUnit;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
@end



/// <code>ReplayLocationManager</code> replays an array of locations exactly as they were
/// recorded with the single exception of the location’s timestamp which will be
/// adjusted by interval between locations.
SWIFT_CLASS_NAMED("ReplayLocationManager")
@interface MBReplayLocationManager : MBNavigationLocationManager
/// <code>speedMultiplier</code> adjusts the speed of the replay.
@property (nonatomic) NSTimeInterval speedMultiplier;
/// <code>locations</code> to be replayed.
@property (nonatomic, copy) NSArray<CLLocation *> * _Null_unspecified locations;
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
- (void)startUpdatingLocation;
- (void)stopUpdatingLocation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class MBRouteProgress;

SWIFT_PROTOCOL("_TtP21VietMapCoreNavigation6Router_")
@protocol Router <CLLocationManagerDelegate>
@property (nonatomic, readonly, strong) MBNavigationLocationManager * _Null_unspecified locationManager;
@property (nonatomic, readonly) BOOL usesDefaultUserInterface;
@property (nonatomic, readonly, strong) MBRouteProgress * _Nonnull routeProgress;
- (void)endNavigation;
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
@end

@protocol MBRouteControllerDelegate;
@class MBDirections;
@class MBRoute;

/// A <code>RouteController</code> tracks the user’s progress along a route, posting notifications as the user reaches significant points along the route. On every location update, the route controller evaluates the user’s location, determining whether the user remains on the route. If not, the route controller calculates a new route.
/// <code>RouteController</code> is responsible for the core navigation logic whereas
/// <code>NavigationViewController</code> is responsible for displaying a default drop-in navigation UI.
SWIFT_CLASS_NAMED("RouteController")
@interface MBRouteController : NSObject <Router>
/// The route controller’s delegate.
@property (nonatomic, weak) id <MBRouteControllerDelegate> _Nullable delegate;
/// The route controller’s associated location manager.
@property (nonatomic, strong) MBNavigationLocationManager * _Null_unspecified locationManager;
/// The Directions object used to create the route.
@property (nonatomic, strong) MBDirections * _Nonnull directions;
/// If true, location updates will be simulated when driving through tunnels or other areas where there is none or bad GPS reception.
@property (nonatomic) BOOL isDeadReckoningEnabled;
/// If true, the <code>RouteController</code> attempts to calculate a more optimal route for the user on an interval defined by <code>routeControllerProactiveReroutingInterval</code>.
@property (nonatomic) BOOL reroutesProactively;
/// Details about the user’s progress along the current route, leg, and step.
@property (nonatomic, strong) MBRouteProgress * _Nonnull routeProgress;
/// :nodoc: This is used internally when the navigation UI is being used
@property (nonatomic) BOOL usesDefaultUserInterface;
/// Intializes a new <code>RouteController</code>.
/// \param route The route to follow.
///
/// \param directions The Directions object that created <code>route</code>.
///
/// \param locationManager The associated location manager.
///
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route directions:(MBDirections * _Nonnull)directions locationManager:(MBNavigationLocationManager * _Nonnull)locationManager OBJC_DESIGNATED_INITIALIZER;
/// Starts monitoring the user’s location along the route.
/// Will continue monitoring until <code>suspendLocationUpdates()</code> is called.
- (void)resume;
/// Stops monitoring the user’s location along the route.
- (void)suspendLocationUpdates;
/// Ends the current navigation session.
- (void)endNavigation;
/// The idealized user location. Snapped to the route line, if applicable, otherwise raw.
/// seealso:
/// snappedLocation, rawLocation
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
@property (nonatomic, readonly) CLLocationDistance reroutingTolerance;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Describes a reason for rerouting and applying a new route
typedef SWIFT_ENUM(NSInteger, RerouteReason, closed) {
/// When we check for a faster route we can also reroute the user when we just want to update the ETA. For example when the user is driving on a route where a Trafficjam appears, it should update the ETA
  RerouteReasonETAUpdate = 0,
/// When the user diverts from the route, we reroute to take the new diversion into account
  RerouteReasonDivertedFromRoute = 1,
/// When the route is faster than the current route, we can also reroute the user
  RerouteReasonFasterRoute = 2,
};

@class MBTunnelIntersectionManager;

/// The <code>TunnelIntersectionManagerDelegate</code> protocol provides methods for responding to events where a user enters or exits a tunnel.
SWIFT_PROTOCOL_NAMED("TunnelIntersectionManagerDelegate")
@protocol MBTunnelIntersectionManagerDelegate
@optional
/// Called immediately when the location manager detects a user will enter a tunnel.
/// \param manager The <code>TunnelIntersectionManager</code> that currently sends the location updates.
///
/// \param location The user’s current location where the tunnel was detected.
///
- (void)tunnelIntersectionManager:(MBTunnelIntersectionManager * _Nonnull)manager willEnableAnimationAtLocation:(CLLocation * _Nonnull)location;
/// Called immediately when the location manager detects the user will exit a tunnel.
/// \param manager The <code>TunnelIntersectionManager</code> that currently sends the location updates.
///
/// \param location The user’s current location where the tunnel was detected.
///
- (void)tunnelIntersectionManager:(MBTunnelIntersectionManager * _Nonnull)manager willDisableAnimationAtLocation:(CLLocation * _Nonnull)location;
@end


@interface MBRouteController (SWIFT_EXTENSION(VietMapCoreNavigation)) <MBTunnelIntersectionManagerDelegate>
- (void)tunnelIntersectionManager:(MBTunnelIntersectionManager * _Nonnull)manager willEnableAnimationAtLocation:(CLLocation * _Nonnull)location;
- (void)tunnelIntersectionManager:(MBTunnelIntersectionManager * _Nonnull)manager willDisableAnimationAtLocation:(CLLocation * _Nonnull)location;
@end

@class CLHeading;

@interface MBRouteController (SWIFT_EXTENSION(VietMapCoreNavigation)) <CLLocationManagerDelegate>
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateHeading:(CLHeading * _Nonnull)newHeading;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
/// Given a users current location, returns a Boolean whether they are currently on the route.
/// If the user is not on the route, they should be rerouted.
- (BOOL)userIsOnRoute:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
@end


/// The <code>RouteControllerDelegate</code> protocol provides methods for responding to significant events during the user’s traversal of a route monitored by a <code>RouteController</code>.
SWIFT_PROTOCOL_NAMED("RouteControllerDelegate")
@protocol MBRouteControllerDelegate
@optional
/// Returns whether the route controller should be allowed to calculate a new route.
/// If implemented, this method is called as soon as the route controller detects that the user is off the predetermined route. Implement this method to conditionally prevent rerouting. If this method returns <code>true</code>, <code>routeController(_:willRerouteFrom:)</code> will be called immediately afterwards.
/// \param routeController The route controller that has detected the need to calculate a new route.
///
/// \param location The user’s current location.
///
///
/// returns:
/// True to allow the route controller to calculate a new route; false to keep tracking the current route.
- (BOOL)routeController:(MBRouteController * _Nonnull)routeController shouldRerouteFromLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
/// Called immediately before the route controller calculates a new route.
/// This method is called after <code>routeController(_:shouldRerouteFrom:)</code> is called, simultaneously with the <code>RouteControllerWillReroute</code> notification being posted, and before <code>routeController(_:didRerouteAlong:)</code> is called.
/// \param routeController The route controller that will calculate a new route.
///
/// \param location The user’s current location.
///
- (void)routeController:(MBRouteController * _Nonnull)routeController willRerouteFromLocation:(CLLocation * _Nonnull)location;
/// Called when a location has been identified as unqualified to navigate on.
/// See <code>CLLocation.isQualified</code> for more information about what qualifies a location.
/// <ul>
///   <li>
///     return: If <code>true</code>, the location is discarded and the <code>RouteController</code> will not consider it. If <code>false</code>, the location will not be thrown out.
///   </li>
/// </ul>
/// \param routeController The route controller that discarded the location.
///
/// \param location The location that will be discarded.
///
- (BOOL)routeController:(MBRouteController * _Nonnull)routeController shouldDiscardLocation:(CLLocation * _Nonnull)location SWIFT_WARN_UNUSED_RESULT;
/// Called immediately after the route controller receives a new route.
/// This method is called after <code>routeController(_:willRerouteFrom:)</code> and simultaneously with the <code>RouteControllerDidReroute</code> notification being posted.
/// \param routeController The route controller that has calculated a new route.
///
/// \param route The new route.
///
/// \param reason Describes the reason of the reroute. Could be due to a faster route / updating ETA or when the user diverted from the suggested route
///
- (void)routeController:(MBRouteController * _Nonnull)routeController didRerouteAlongRoute:(MBRoute * _Nonnull)route reason:(enum RerouteReason)reason;
/// Called when the route controller fails to receive a new route.
/// This method is called after <code>routeController(_:willRerouteFrom:)</code> and simultaneously with the <code>RouteControllerDidFailToReroute</code> notification being posted.
/// \param routeController The route controller that has calculated a new route.
///
/// \param error An error raised during the process of obtaining a new route.
///
- (void)routeController:(MBRouteController * _Nonnull)routeController didFailToRerouteWithError:(NSError * _Nonnull)error;
/// Called when the route controller’s location manager receives a location update.
/// These locations may be modified due to replay or simulation and can
/// also derive from regular location updates from a <code>CLLocationManager</code>.
/// \param routeController The route controller that received the new locations.
///
/// \param locations The locations that were received from the associated location manager.
///
- (void)routeController:(MBRouteController * _Nonnull)routeController didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
/// Called when the route controller arrives at a waypoint.
/// You can implement this method to prevent the route controller from automatically advancing to the next leg. For example, you can and show an interstitial sheet upon arrival and pause navigation by returning <code>false</code>, then continue the route when the user dismisses the sheet. If this method is unimplemented, the route controller automatically advances to the next leg when arriving at a waypoint.
/// postcondition:
/// If you return false, you must manually advance to the next leg: obtain the value of the <code>routeProgress</code> property, then increment the <code>RouteProgress.legIndex</code> property.
/// \param routeController The route controller that has arrived at a waypoint.
///
/// \param waypoint The waypoint that the controller has arrived at.
///
///
/// returns:
/// True to advance to the next leg, if any, or false to remain on the completed leg.
- (BOOL)routeController:(MBRouteController * _Nonnull)routeController didArriveAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
/// Called when the route controller arrives at a waypoint.
/// You can implement this method to allow the route controller to continue check and reroute the user if needed. By default, the user will not be rerouted when arriving at a waypoint.
/// \param routeController The route controller that has arrived at a waypoint.
///
/// \param waypoint The waypoint that the controller has arrived at.
///
///
/// returns:
/// True to prevent the route controller from checking if the user should be rerouted.
- (BOOL)routeController:(MBRouteController * _Nonnull)routeController shouldPreventReroutesWhenArrivingAtWaypoint:(MBWaypoint * _Nonnull)waypoint SWIFT_WARN_UNUSED_RESULT;
/// Called when the route controller will disable battery monitoring.
/// Implementing this method will allow developers to change whether battery monitoring is disabled when <code>RouteController</code> is deinited.
/// \param routeController The route controller that will change the state of battery monitoring.
///
///
/// returns:
/// A bool indicating whether to disable battery monitoring when the RouteController is deinited.
- (BOOL)routeControllerShouldDisableBatteryMonitoring:(MBRouteController * _Nonnull)routeController SWIFT_WARN_UNUSED_RESULT;
@end

@class MBRouteLeg;
@class MBRouteStep;
@class MBRouteStepProgress;

/// <code>RouteLegProgress</code> stores the user’s progress along a route leg.
SWIFT_CLASS_NAMED("RouteLegProgress")
@interface MBRouteLegProgress : NSObject
/// Returns the current <code>RouteLeg</code>.
@property (nonatomic, readonly, strong) MBRouteLeg * _Nonnull leg;
/// Index representing the current step.
@property (nonatomic) NSInteger stepIndex;
/// The remaining steps for user to complete.
@property (nonatomic, readonly, copy) NSArray<MBRouteStep *> * _Nonnull remainingSteps;
/// Total distance traveled in meters along current leg.
@property (nonatomic, readonly) CLLocationDistance distanceTraveled;
/// Duration remaining in seconds on current leg.
@property (nonatomic, readonly) NSTimeInterval durationRemaining;
/// Distance remaining on the current leg.
@property (nonatomic, readonly) CLLocationDistance distanceRemaining;
/// Number between 0 and 1 representing how far along the current leg the user has traveled.
@property (nonatomic, readonly) double fractionTraveled;
@property (nonatomic) BOOL userHasArrivedAtWaypoint;
/// Returns the <code>RouteStep</code> before a given step. Returns <code>nil</code> if there is no step prior.
- (MBRouteStep * _Nullable)stepBefore:(MBRouteStep * _Nonnull)step SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>RouteStep</code> after a given step. Returns <code>nil</code> if there is not a step after.
- (MBRouteStep * _Nullable)stepAfter:(MBRouteStep * _Nonnull)step SWIFT_WARN_UNUSED_RESULT;
/// Returns the <code>RouteStep</code> before the current step.
/// If there is no <code>priorStep</code>, nil is returned.
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable priorStep;
/// Returns the current <code>RouteStep</code> for the leg the user is on.
@property (nonatomic, readonly, strong) MBRouteStep * _Nonnull currentStep;
/// Returns the upcoming <code>RouteStep</code>.
/// If there is no <code>upcomingStep</code>, nil is returned.
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable upComingStep;
/// Returns step 2 steps ahead.
/// If there is no <code>followOnStep</code>, nil is returned.
@property (nonatomic, readonly, strong) MBRouteStep * _Nullable followOnStep;
/// Return bool whether step provided is the current <code>RouteStep</code> the user is on.
- (BOOL)isCurrentStep:(MBRouteStep * _Nonnull)step SWIFT_WARN_UNUSED_RESULT;
/// Returns the progress along the current <code>RouteStep</code>.
@property (nonatomic, strong) MBRouteStepProgress * _Nonnull currentStepProgress;
/// Intializes a new <code>RouteLegProgress</code>.
/// \param leg Leg on a <code>Route</code>.
///
/// \param stepIndex Current step the user is on.
///
- (nonnull instancetype)initWithLeg:(MBRouteLeg * _Nonnull)leg stepIndex:(NSInteger)stepIndex spokenInstructionIndex:(NSInteger)spokenInstructionIndex OBJC_DESIGNATED_INITIALIZER;
/// Returns an array of <code>CLLocationCoordinate2D</code> of the prior, current and upcoming step geometry.
@property (nonatomic, readonly, copy) NSArray<NSValue *> * _Nonnull nearbyCoordinates;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// <code>RouteProgress</code> stores the user’s progress along a route.
SWIFT_CLASS_NAMED("RouteProgress")
@interface MBRouteProgress : NSObject
/// Returns the current <code>Route</code>.
@property (nonatomic, readonly, strong) MBRoute * _Nonnull route;
/// Index representing current <code>RouteLeg</code>.
@property (nonatomic) NSInteger legIndex;
/// If waypoints are provided in the <code>Route</code>, this will contain which leg the user is on.
@property (nonatomic, readonly, strong) MBRouteLeg * _Nonnull currentLeg;
/// Total distance traveled by user along all legs.
@property (nonatomic, readonly) CLLocationDistance distanceTraveled;
/// Total seconds remaining on all legs.
@property (nonatomic, readonly) NSTimeInterval durationRemaining;
/// Number between 0 and 1 representing how far along the <code>Route</code> the user has traveled.
@property (nonatomic, readonly) double fractionTraveled;
/// Total distance remaining in meters along route.
@property (nonatomic, readonly) CLLocationDistance distanceRemaining;
/// Number of waypoints remaining on the current route.
@property (nonatomic, readonly, copy) NSArray<MBWaypoint *> * _Nonnull remainingWaypoints;
/// Returns the progress along the current <code>RouteLeg</code>.
@property (nonatomic, strong) MBRouteLegProgress * _Nonnull currentLegProgress;
/// Intializes a new <code>RouteProgress</code>.
/// \param route The route to follow.
///
/// \param legIndex Zero-based index indicating the current leg the user is on.
///
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route legIndex:(NSInteger)legIndex spokenInstructionIndex:(NSInteger)spokenInstructionIndex OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class MBIntersection;
@class MBVisualInstructionBanner;
@class MBSpokenInstruction;

/// <code>RouteStepProgress</code> stores the user’s progress along a route step.
SWIFT_CLASS_NAMED("RouteStepProgress")
@interface MBRouteStepProgress : NSObject
/// Returns the current <code>RouteStep</code>.
@property (nonatomic, readonly, strong) MBRouteStep * _Nonnull step;
/// Returns distance user has traveled along current step.
@property (nonatomic) CLLocationDistance distanceTraveled;
/// Returns distance from user to end of step.
@property (nonatomic) CLLocationDistance userDistanceToManeuverLocation;
/// Total distance in meters remaining on current step.
@property (nonatomic, readonly) CLLocationDistance distanceRemaining;
/// Number between 0 and 1 representing fraction of current step traveled.
@property (nonatomic, readonly) double fractionTraveled;
/// Number of seconds remaining on current step.
@property (nonatomic, readonly) NSTimeInterval durationRemaining;
/// Intializes a new <code>RouteStepProgress</code>.
/// \param step Step on a <code>RouteLeg</code>.
///
- (nonnull instancetype)initWithStep:(MBRouteStep * _Nonnull)step spokenInstructionIndex:(NSInteger)spokenInstructionIndex OBJC_DESIGNATED_INITIALIZER;
/// All intersections on the current <code>RouteStep</code> and also the first intersection on the upcoming <code>RouteStep</code>.
/// The upcoming <code>RouteStep</code> first <code>Intersection</code> is added because it is omitted from the current step.
@property (nonatomic, copy) NSArray<MBIntersection *> * _Nullable intersectionsIncludingUpcomingManeuverIntersection;
/// The next intersection the user will travel through.
/// The step must contain <code>intersectionsIncludingUpcomingManeuverIntersection</code> otherwise this property will be <code>nil</code>.
@property (nonatomic, readonly, strong) MBIntersection * _Nullable upcomingIntersection;
/// Index representing the current intersection.
@property (nonatomic) NSInteger intersectionIndex;
/// The current intersection the user will travel through.
/// The step must contain <code>intersectionsIncludingUpcomingManeuverIntersection</code> otherwise this property will be <code>nil</code>.
@property (nonatomic, readonly, strong) MBIntersection * _Nullable currentIntersection;
/// Returns an array of the calculated distances from the current intersection to the next intersection on the current step.
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable intersectionDistances;
/// Index into <code>step.instructionsDisplayedAlongStep</code> representing the current visual instruction for the step.
@property (nonatomic) NSInteger visualInstructionIndex;
/// An <code>Array</code> of remaining <code>VisualInstruction</code> for a step.
@property (nonatomic, readonly, copy) NSArray<MBVisualInstructionBanner *> * _Nullable remainingVisualInstructions;
/// Index into <code>step.instructionsSpokenAlongStep</code> representing the current spoken instruction.
@property (nonatomic) NSInteger spokenInstructionIndex;
/// An <code>Array</code> of remaining <code>SpokenInstruction</code> for a step.
@property (nonatomic, readonly, copy) NSArray<MBSpokenInstruction *> * _Nullable remainingSpokenInstructions;
/// Current spoken instruction for the user’s progress along a step.
@property (nonatomic, readonly, strong) MBSpokenInstruction * _Nullable currentSpokenInstruction;
/// Current visual instruction for the user’s progress along a step.
@property (nonatomic, readonly, strong) MBVisualInstructionBanner * _Nullable currentVisualInstruction;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// The <code>SimulatedLocationManager</code> class simulates location updates along a given route.
/// The route will be replaced upon a <code>RouteControllerDidReroute</code> notification.
SWIFT_CLASS_NAMED("SimulatedLocationManager")
@interface MBSimulatedLocationManager : MBNavigationLocationManager
/// Specify the multiplier to use when calculating speed based on the RouteLeg’s <code>expectedSegmentTravelTimes</code>.
@property (nonatomic) double speedMultiplier;
@property (nonatomic, readonly, strong) CLLocation * _Nullable location;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
/// Initalizes a new <code>SimulatedLocationManager</code> with the given route.
/// \param route The initial route.
///
///
/// returns:
/// A <code>SimulatedLocationManager</code>
- (nonnull instancetype)initWithRoute:(MBRoute * _Nonnull)route OBJC_DESIGNATED_INITIALIZER;
/// Initalizes a new <code>SimulatedLocationManager</code> with the given routeProgress.
/// \param routeProgress The routeProgress of the current route.
///
///
/// returns:
/// A <code>SimulatedLocationManager</code>
- (nonnull instancetype)initWithRouteProgress:(MBRouteProgress * _Nonnull)routeProgress OBJC_DESIGNATED_INITIALIZER;
- (void)startUpdatingLocation;
- (void)stopUpdatingLocation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("TunnelIntersectionManager")
@interface MBTunnelIntersectionManager : NSObject
/// The associated delegate for tunnel intersection manager.
@property (nonatomic, weak) id <MBTunnelIntersectionManagerDelegate> _Nullable delegate;
/// The simulated location manager dedicated to tunnel simulated navigation.
@property (nonatomic, strong) MBSimulatedLocationManager * _Nullable animatedLocationManager;
/// An array of bad location updates recorded upon exit of a tunnel.
@property (nonatomic, copy) NSArray<CLLocation *> * _Nonnull tunnelExitLocations;
/// Flag indicating whether the user is animated through tunnels.
@property (nonatomic) BOOL tunnelSimulationEnabled;
/// Given a user’s current location and the route progress,
/// detects whether the upcoming intersection contains a tunnel road class, and
/// returns a Boolean whether they are within the minimum radius of a tunnel entrance.
- (BOOL)userWithinTunnelEntranceRadiusAt:(CLLocation * _Nonnull)location routeProgress:(MBRouteProgress * _Nonnull)routeProgress SWIFT_WARN_UNUSED_RESULT;
- (void)enableTunnelAnimationWithRouteController:(MBRouteController * _Nonnull)routeController routeProgress:(MBRouteProgress * _Nonnull)routeProgress;
- (void)suspendTunnelAnimationAt:(CLLocation * _Nonnull)location routeController:(MBRouteController * _Nonnull)routeController;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




@interface UIDevice (SWIFT_EXTENSION(VietMapCoreNavigation))
/// Returns a <code>Bool</code> whether the device is plugged in. Returns false if not an iOS device.
@property (nonatomic, readonly) BOOL isPluggedIn;
@end



#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
